{\rtf1\ansi\ansicpg1252\cocoartf1671
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww14900\viewh13080\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Comparison between Banket and BanketNoWait\
\
BanketNoWait is a messy way to approach the problem. It is hard to identify the sequence of actions, even when using messages that indicate the actions that have been just performed. This is because the objects are all trying to access the main object as soon as possible, and we can only see this thanks to the addition of Thread.sleep(200), otherwise we may fall into a deadlock where one Thread blocks the others. There is no controlled order of actions, and that\'92s what we can see in the console output, where some actions report results in strange sequences that fall from the desired logic of the program. Although it is possible to prevent the count of servings falling to a negative value, this requires including conditionals that don\'92t offer much reliability.\
\
Banket, using the monitor Pot, makes sure that the Threads follow an order. Thanks to the use of synchronized methods, we can assure that only one thread is using the main object Pot at any given item, in that way it is possible to trace the logic of the system. Threads that are not allowed to perform certain actions due to constraints of the system are kept waiting until the necessary conditions have been fulfilled for them to resume their actions. So, we avoid the interference of any Thread in the sequence of the process. In this way we can assure that we have control over the sequence of actions of the system.}