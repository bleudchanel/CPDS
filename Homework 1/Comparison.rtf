{\rtf1\ansi\ansicpg1252\cocoartf1671
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww19260\viewh13700\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Comparison between Banket and BanketNoWait\
\
BanketNoWait is a messy way to approach the problem. It is hard to identify the sequence of actions, even when using messages that indicate the actions that have been just performed. This is because the objects are all trying to access the main object as soon as possible, and we can only see this thanks to the addition of Thread.sleep(200), otherwise we may fall into a deadlock where one Thread blocks the others. There is no controlled order of actions, and that\'92s what we can see in the console output, where some actions report results in strange sequences that fall from the desired logic of the program. Although it is possible to prevent the count of servings falling to a negative value, this requires including conditionals that don\'92t offer much reliability and make the program more complex than necessary.\
\
Banket, using the monitor Pot, makes sure that the Threads follow a planned order. Thanks to the use of synchronized methods, we can assure that only one thread is using the main object Pot at any given item, that is, mutual exclusion. So, we avoid the interference of any Thread in the sequence of the process. Threads that are not allowed to perform certain actions due to constraints of the system are kept waiting until the necessary conditions have been fulfilled for them to resume their actions, and then they awake in an orderly fashion following the same rules of mutual exclusion as before. The solution is clean and the Threads perform their actions as expected.}